<import name="tab-bar-item" src="./../../components/TabBarItem"></import>
<template>
  <div class="page-wrapper main-page">
    <list class="favorite-list">
      <list-item class='favorite' for='poetries' type='poetry'>
        <text class='fav'>{{ $item.title }}</text>
      </list-item>
    </list>
    <div class="bottom-area wrapper-padding">
      <tab-bar-item index="0" path="./../../assets/icons/change.svg" @click="findMore"></tab-bar-item>
      <tab-bar-item index="1" path="{{favoritesPath}}" size="large" @click="favoritesUpdate"></tab-bar-item>
      <tab-bar-item index="2" path="./../../assets/icons/share.svg" @click="poetryShare"></tab-bar-item>
    </div>
    
  </div>
</template>

<script>
  import router from '@system.router'
  import app from '@system.app'
  import storage from '@system.storage'
  import poetries from '../../data/poetries'

  const FAVORITES = 'favoritesList'
  const appInfo = app.getInfo()

  export default {
    // 页面级组件的数据模型，影响传入数据的覆盖机制：private内定义的属性不允许被覆盖
    private: {
      poetries: [],
      currentIndex: 0,
      favoritesList: {},
      favoritesPath: './../../assets/icons/favorites_empty.svg'
    },

    protected: {
      title: appInfo.name,
      icon: appInfo.icon
    },

    onInit () {
      storage.get({
        key: FAVORITES,
        success: (data) => {
          try {
              if (data){
                const map = JSON.parse(data) || {}
                this.msg = data
                this.favoritesList = map
                this.poetries = poetries.filter(poetry => map[poetry.id])
                this.iconCtrl(this.poetries.length)
              }
           } catch (e) {
             console.log(e)
          }
        },
        fail: (data, code) => {
          console.log('data', data, 'code', code)
        }
      })
    },

    onShow () {
      APP_STATISTICS.page_show(this)
      /**
       * @desc: 调用 API：global.$apis || this.$app._def.$apis (前者更简洁);
       */
      const params = { active: true }
      // global.$apis.links.getAllLinksCount(params).then(result => {
      //   this.poetries = poetries
      // }).catch((error) => {
      //   console.log(error)
      // })
    },

    onHide() {
      APP_STATISTICS.page_hide(this)
    },

    onMenuPress () {
      this.$app.$def.showMenu()
    },

    swiperUpdate ({index}) {
      this.currentIndex = index
      const id = this.poetries[this.currentIndex].id.toString()
      this.iconCtrl(this.favoritesList[id])
    },

    favoritesUpdate () {
      const id = this.poetries[this.currentIndex].id.toString()
      this.favoritesList[id] = !this.favoritesList[id]
      this.iconCtrl(this.favoritesList[id])
      storage.set({
        key: FAVORITES,
        value: this.favoritesList
      })
    },

    iconCtrl (show) {
      if(show){
        this.favoritesPath = './../../assets/icons/favorites.svg'
      }else{
        this.favoritesPath = './../../assets/icons/favorites_empty.svg'
      }
    },

    findMore () {
      // 换一批（用batchChange不知为何报错。）
      // 这里调用随机拉取接口，并替换poetries数据
    },

    poetryShare () {
      // 分享
    }
  }
</script>

<style lang="less">
  @import './../../assets/styles/style.less';
  .main-page {
    .flex-box-mixins(column, center, center);
    background-image: url('./../../assets/images/bg.jpeg');
    width: 100%;
    .bottom-area {
      .flex-box-mixins(row, center, center);
      width: 100%;
      height: 30 * @size-factor;
      background-color: @white-grey;
      .countup-text {
        color: @black;
        font-size: 6 * @size-factor;
      }
      .countup {
        font-size: 10 * @size-factor;
      }
    }
  }
  .list {
    margin: 20px;
  }
  .favorite {
    padding: 20px 50px;
    border-top-width: 1px;
    border-top-style: solid;
    border-top-color: #ccc;
    background-color: rgba(255, 255, 255, 0.5);
    .fav {
      font-size: 6 * @size-factor;
    }
  }
</style>
